---
title: Chapter 1 - ROS 2 Foundations
sidebar_label: ROS 2 Foundations
---

# Chapter 1: ROS 2 Foundations

## Learning Objectives

By the end of this chapter, you will be able to:
- Explain the architecture and core concepts of ROS 2
- Understand the differences between ROS 1 and ROS 2
- Set up a ROS 2 development environment
- Create and run basic ROS 2 packages and nodes
- Use ROS 2 command-line tools for introspection and debugging

## Physical AI Concept

ROS 2 serves as the foundational communication layer that enables Physical AI systems to integrate perception, decision-making, and action. In embodied intelligence, the ability for different components to communicate reliably and efficiently is critical for coordinating complex behaviors. ROS 2's distributed architecture allows for modular development while maintaining tight integration between physical sensors/actuators and AI systems.

## System Architecture

### ROS 2 vs ROS 1 Architecture

ROS 2 addresses key limitations of ROS 1 by implementing a more robust, secure, and scalable architecture:

```
ROS 1 Architecture:                    ROS 2 Architecture:
┌─────────────────┐                   ┌─────────────────┐
│   Master        │                   │   DDS Network   │
│   (Centralized) │                   │   (Decentralized)│
│                 │                   │                 │
│  Single point   │                   │  Multiple       │
│  of failure     │                   │  communication  │
└─────────┬───────┘                   │  domains       │
          │                           └─────────┬───────┘
          │                                     │
    ┌─────▼─────────────────────────────────────▼─────┐
    │               Robot System                    │
    │  ┌─────────┐    ┌─────────┐    ┌─────────┐   │
    │  │ Node A  │    │ Node B  │    │ Node C  │   │
    │  │         │    │         │    │         │   │
    │  └─────────┘    └─────────┘    └─────────┘   │
    └───────────────────────────────────────────────┘
```

Key improvements in ROS 2:
- **Decentralized**: No single master node; uses DDS for discovery
- **Secure**: Built-in authentication and encryption capabilities
- **Real-time**: Deterministic performance with QoS policies
- **Multi-platform**: Better Windows and macOS support
- **Standardized**: Based on OMG DDS standard for interoperability

### Core ROS 2 Concepts

1. **Nodes**: Independent processes that perform computation
2. **Topics**: Named buses over which nodes exchange messages
3. **Services**: Synchronous request/response communication
4. **Actions**: Asynchronous goal-oriented communication
5. **Parameters**: Configuration values that can be changed at runtime
6. **Lifecycle**: State management for complex node behaviors

## Tools & Software

This chapter uses:
- **ROS 2 Humble Hawksbill** - Core framework
- **rclpy** - Python ROS 2 client library
- **rclcpp** - C++ ROS 2 client library
- **ros2 command-line tools** - For introspection and management
- **RViz2** - Visualization tool
- **rqt** - GUI tools for debugging

## Code / Configuration Examples

### Setting up a ROS 2 Workspace

```bash
# Create workspace directory
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws

# Source ROS 2 environment
source /opt/ros/humble/setup.bash

# Build the workspace
colcon build

# Source the workspace
source install/setup.bash
```

### Creating a Basic ROS 2 Package

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_python my_robot_pkg
```

This creates a package structure:
```
my_robot_pkg/
├── my_robot_pkg/
│   ├── __init__.py
│   └── my_node.py
├── setup.py
├── setup.cfg
├── package.xml
└── resource/my_robot_pkg
```

### Basic Publisher Node

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Basic Subscriber Node

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Running the Publisher and Subscriber

```bash
# Terminal 1: Run the publisher
ros2 run my_robot_pkg minimal_publisher

# Terminal 2: Run the subscriber
ros2 run my_robot_pkg minimal_subscriber
```

## Practical Lab / Simulation

### Lab Exercise 1: ROS 2 Environment Setup

1. Install ROS 2 Humble Hawksbill following the official installation guide
2. Create a new workspace and build it
3. Source the ROS 2 environment in your shell
4. Verify installation with `ros2 --version`
5. Explore available ROS 2 packages with `ros2 pkg list`

### Lab Exercise 2: Basic Publisher-Subscriber Communication

1. Create a new ROS 2 package named `robot_tutorial`
2. Implement the publisher and subscriber nodes as shown in the examples
3. Build the package using `colcon build`
4. Run both nodes in separate terminals
5. Observe the message exchange between nodes
6. Use `ros2 topic list` and `ros2 topic echo` to introspect topics

### Lab Exercise 3: Parameter Configuration

1. Add parameters to your publisher node to configure the message content
2. Use `ros2 param list` to view available parameters
3. Modify parameters at runtime using `ros2 param set`
4. Implement parameter callbacks to handle parameter changes

## Real-World Mapping

### Industrial Applications
- **Automotive**: ROS 2 is used in autonomous vehicle development for sensor fusion, path planning, and control
- **Manufacturing**: Industrial robots use ROS 2 for task coordination and communication with factory systems
- **Agriculture**: Autonomous farming equipment utilizes ROS 2 for navigation and control

### Research Applications
- **Space Exploration**: NASA's Mars 2020 Perseverance rover used ROS-inspired architectures
- **Healthcare**: Surgical robots and assistive devices use ROS 2 for precise control and safety
- **Academia**: Universities worldwide use ROS 2 for robotics research and education

### Key Success Factors
- **Modularity**: ROS 2's component-based architecture enables rapid prototyping
- **Standardization**: Common interfaces facilitate integration of third-party components
- **Scalability**: Can run from embedded systems to cloud-based processing
- **Community**: Large ecosystem of packages and tools accelerates development

## Summary

Chapter 1 has introduced the foundational concepts of ROS 2, the communication framework that enables Physical AI systems to coordinate complex behaviors. We've covered the architectural improvements over ROS 1, core concepts including nodes, topics, and services, and practical examples of implementing basic ROS 2 nodes. The hands-on lab exercises provide experience with the development workflow and debugging tools essential for building robotic systems. This foundation prepares you for more advanced topics in robot communication, perception, and control that will be covered in subsequent chapters.