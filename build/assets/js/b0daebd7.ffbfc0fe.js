"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[294],{1829:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"modules/module-02-gazebo-unity/physics-based-simulation","title":"Chapter 4 - Physics-Based Simulation","description":"Learning Objectives","source":"@site/docs/modules/module-02-gazebo-unity/physics-based-simulation.mdx","sourceDirName":"modules/module-02-gazebo-unity","slug":"/modules/module-02-gazebo-unity/physics-based-simulation","permalink":"/docs/modules/module-02-gazebo-unity/physics-based-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/modules/module-02-gazebo-unity/physics-based-simulation.mdx","tags":[],"version":"current","frontMatter":{"title":"Chapter 4 - Physics-Based Simulation","sidebar_label":"Physics-Based Simulation"},"sidebar":"tutorialSidebar","previous":{"title":"Gazebo Simulation","permalink":"/docs/modules/module-02-gazebo-unity/gazebo-simulation"},"next":{"title":"Sim2Real Transfer","permalink":"/docs/modules/module-02-gazebo-unity/sim2real-transfer"}}');var t=i(4848),o=i(8453);const a={title:"Chapter 4 - Physics-Based Simulation",sidebar_label:"Physics-Based Simulation"},r="Chapter 4: Physics-Based Simulation",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Physical AI Concept",id:"physical-ai-concept",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Physics Engine Architecture",id:"physics-engine-architecture",level:3},{value:"Physics Simulation Pipeline",id:"physics-simulation-pipeline",level:3},{value:"Tools &amp; Software",id:"tools--software",level:2},{value:"Code / Configuration Examples",id:"code--configuration-examples",level:2},{value:"Physics Engine Configuration and Robot Model",id:"physics-engine-configuration-and-robot-model",level:3},{value:"Advanced Physics Configuration with Custom Constraints",id:"advanced-physics-configuration-with-custom-constraints",level:3},{value:"Physics Validation and Comparison",id:"physics-validation-and-comparison",level:3},{value:"Practical Lab / Simulation",id:"practical-lab--simulation",level:2},{value:"Lab Exercise 1: Physics Engine Setup and Configuration",id:"lab-exercise-1-physics-engine-setup-and-configuration",level:3},{value:"Lab Exercise 2: Rigid Body Dynamics",id:"lab-exercise-2-rigid-body-dynamics",level:3},{value:"Lab Exercise 3: Articulated Robot Simulation",id:"lab-exercise-3-articulated-robot-simulation",level:3},{value:"Lab Exercise 4: Contact Mechanics and Friction",id:"lab-exercise-4-contact-mechanics-and-friction",level:3},{value:"Lab Exercise 5: Physics Validation",id:"lab-exercise-5-physics-validation",level:3},{value:"Lab Exercise 6: Performance Optimization",id:"lab-exercise-6-performance-optimization",level:3},{value:"Real-World Mapping",id:"real-world-mapping",level:2},{value:"Industrial Applications",id:"industrial-applications",level:3},{value:"Research Applications",id:"research-applications",level:3},{value:"Key Success Factors",id:"key-success-factors",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-4-physics-based-simulation",children:"Chapter 4: Physics-Based Simulation"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the fundamentals of physics engines used in robotics simulation"}),"\n",(0,t.jsx)(e.li,{children:"Implement accurate physics models for humanoid robot dynamics"}),"\n",(0,t.jsx)(e.li,{children:"Configure collision detection and response for realistic interactions"}),"\n",(0,t.jsx)(e.li,{children:"Optimize simulation performance while maintaining accuracy"}),"\n",(0,t.jsx)(e.li,{children:"Validate physics simulation against real-world robot behavior"}),"\n",(0,t.jsx)(e.li,{children:"Design physics-based training scenarios for humanoid robots"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"physical-ai-concept",children:"Physical AI Concept"}),"\n",(0,t.jsx)(e.p,{children:"Physics-based simulation is the cornerstone of Physical AI, providing the computational foundation that enables robots to understand and interact with the physical world. For humanoid robotics, accurate physics simulation is essential because these robots must maintain balance, manipulate objects, and navigate complex environments using the same physical laws that govern real-world interactions. Physics engines model fundamental forces like gravity, friction, and collision, allowing robots to develop intuitive understanding of physical consequences."}),"\n",(0,t.jsx)(e.p,{children:"Key aspects of physics in Physical AI:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamics Modeling"}),": Accurate representation of forces, torques, and motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact Mechanics"}),": Realistic modeling of collisions and interactions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability Analysis"}),": Understanding balance and equilibrium in physical systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Energy Conservation"}),": Proper modeling of energy transfer and dissipation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-body Systems"}),": Complex interactions between multiple connected bodies"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,t.jsx)(e.h3,{id:"physics-engine-architecture",children:"Physics Engine Architecture"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Physics Simulation Architecture:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Physics Engine Core                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   Integration   \u2502  \u2502   Collision     \u2502  \u2502   Constraint    \u2502    \u2502\n\u2502  \u2502   Engine        \u2502  \u2502   Detection     \u2502  \u2502   Solver        \u2502    \u2502\n\u2502  \u2502  \u2022 ODE Solvers  \u2502  \u2502  \u2022 Broad Phase  \u2502  \u2502  \u2022 Joint       \u2502    \u2502\n\u2502  \u2502  \u2022 Time Stepping\u2502  \u2502  \u2022 Narrow Phase \u2502  \u2502    Constraints \u2502    \u2502\n\u2502  \u2502  \u2022 Stability    \u2502  \u2502  \u2022 Contact      \u2502  \u2502  \u2022 Motors      \u2502    \u2502\n\u2502  \u2502    Preservation \u2502  \u2502    Generation   \u2502  \u2502  \u2022 Contacts    \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502              \u2502                    \u2502                    \u2502           \u2502\n\u2502              \u25bc                    \u25bc                    \u25bc           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              Physics Components                             \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502  \u2502\n\u2502  \u2502  \u2502  Rigid Body \u2502  \u2502  Articulated \u2502  \u2502  Soft Body  \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  Dynamics   \u2502  \u2502  Systems    \u2502  \u2502  Simulation \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Mass     \u2502  \u2502  \u2022 Joints    \u2502  \u2502  \u2022 Deformable\u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Inertia  \u2502  \u2502  \u2022 Kinematics\u2502  \u2502  \u2022 Cloth    \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Forces   \u2502  \u2502  \u2022 Dynamics  \u2502  \u2502  \u2022 Fluids   \u2502        \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                     \u2502                            \u2502\n\u2502                                     \u25bc                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              Simulation Integration                         \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502  \u2502\n\u2502  \u2502  \u2502  Control    \u2502  \u2502  Perception  \u2502  \u2502  Planning   \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  Interface  \u2502  \u2502  Integration \u2502  \u2502  Integration \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Commands \u2502  \u2502  \u2022 Sensor    \u2502  \u2502  \u2022 Trajectory\u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Feedback \u2502  \u2502    Simulation\u2502  \u2502    Planning \u2502        \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.h3,{id:"physics-simulation-pipeline",children:"Physics Simulation Pipeline"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Physics Simulation Loop:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   State Update  \u2502\u2500\u2500\u2500\u25b6\u2502  Force          \u2502\u2500\u2500\u2500\u25b6\u2502  Integration    \u2502\n\u2502   \u2022 Positions   \u2502    \u2502  Calculation    \u2502    \u2502  \u2022 ODE Solving  \u2502\n\u2502   \u2022 Velocities  \u2502    \u2502  \u2022 Gravity     \u2502    \u2502  \u2022 Time Step    \u2502\n\u2502   \u2022 Constraints \u2502    \u2502  \u2022 Springs     \u2502    \u2502  \u2022 Stability    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502  \u2022 Contacts    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502               \u2502  \u2022 Motors      \u2502              \u2502\n         \u25bc               \u2502  \u2022 Damping     \u2502              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Collision     \u2502\u2500\u2500\u2500\u25b6\u2502  Constraint     \u2502\u2500\u2500\u2500\u25b6\u2502   State         \u2502\n\u2502   Detection     \u2502    \u2502  Resolution     \u2502    \u2502   Output        \u2502\n\u2502  \u2022 Broad Phase  \u2502    \u2502  \u2022 Joint       \u2502    \u2502  \u2022 Updated      \u2502\n\u2502  \u2022 Narrow Phase \u2502    \u2502    Constraints \u2502    \u2502    Positions    \u2502\n\u2502  \u2022 Contacts     \u2502    \u2502  \u2022 Contact     \u2502    \u2502  \u2022 Velocities   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502    Resolution  \u2502    \u2502  \u2022 Forces       \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.h2,{id:"tools--software",children:"Tools & Software"}),"\n",(0,t.jsx)(e.p,{children:"This chapter uses:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"})," - Classic physics engine for robotics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bullet Physics"})," - Modern physics engine with good robotics support"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"MuJoCo"})," - Advanced physics engine for research applications"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"NVIDIA PhysX"})," - High-performance physics engine"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"PyBullet"})," - Python wrapper for Bullet physics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo"})," - Integration of physics engines with robotics simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity Physics"})," - Physics engine integrated with Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2"})," - Integration with robot control systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"code--configuration-examples",children:"Code / Configuration Examples"}),"\n",(0,t.jsx)(e.h3,{id:"physics-engine-configuration-and-robot-model",children:"Physics Engine Configuration and Robot Model"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import pybullet as p\nimport pybullet_data\nimport numpy as np\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Vector3\nimport time\n\nclass PhysicsBasedRobotSimulator(Node):\n    def __init__(self):\n        super().__init__(\'physics_robot_simulator\')\n\n        # Connect to physics engine\n        self.physics_client = p.connect(p.GUI)  # Use p.DIRECT for headless\n        p.setAdditionalSearchPath(pybullet_data.getDataPath())\n\n        # Set gravity\n        p.setGravity(0, 0, -9.81, physicsClientId=self.physics_client)\n\n        # Publishers for sensor data\n        self.joint_state_pub = self.create_publisher(JointState, \'/joint_states\', 10)\n        self.imu_pub = self.create_publisher(Imu, \'/imu/data\', 10)\n\n        # Timer for physics simulation\n        self.sim_timer = self.create_timer(0.01, self.simulation_step)  # 100 Hz\n\n        # Robot properties\n        self.robot_id = None\n        self.joint_indices = []\n        self.joint_names = []\n\n        # Initialize simulation environment\n        self.setup_environment()\n\n        self.get_logger().info(\'Physics-based robot simulator initialized\')\n\n    def setup_environment(self):\n        """Set up the physics environment and load robot"""\n        # Load plane\n        self.plane_id = p.loadURDF("plane.urdf")\n\n        # Load robot (using a simple humanoid model)\n        # In practice, you would load your custom URDF\n        self.robot_id = p.loadURDF(\n            "r2d2.urdf",  # Replace with humanoid model\n            [0, 0, 1],\n            p.getQuaternionFromEuler([0, 0, 0]),\n            flags=p.URDF_USE_INERTIA_FROM_FILE\n        )\n\n        # Get joint information\n        num_joints = p.getNumJoints(self.robot_id)\n        for i in range(num_joints):\n            joint_info = p.getJointInfo(self.robot_id, i)\n            joint_name = joint_info[1].decode(\'utf-8\')\n            joint_type = joint_info[2]\n\n            # Only include revolute and prismatic joints (not fixed)\n            if joint_type in [p.JOINT_REVOLUTE, p.JOINT_PRISMATIC]:\n                self.joint_indices.append(i)\n                self.joint_names.append(joint_name)\n\n        self.get_logger().info(f\'Loaded robot with {len(self.joint_indices)} controllable joints\')\n\n    def simulation_step(self):\n        """Execute one step of physics simulation"""\n        # Step physics simulation\n        p.stepSimulation(physicsClientId=self.physics_client)\n\n        # Publish sensor data\n        self.publish_joint_states()\n        self.publish_imu_data()\n\n    def publish_joint_states(self):\n        """Publish joint state information"""\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = []\n        msg.position = []\n        msg.velocity = []\n        msg.effort = []\n\n        for i, joint_index in enumerate(self.joint_indices):\n            joint_state = p.getJointState(self.robot_id, joint_index)\n            joint_name = self.joint_names[i]\n\n            msg.name.append(joint_name)\n            msg.position.append(joint_state[0])  # Position\n            msg.velocity.append(joint_state[1])  # Velocity\n            msg.effort.append(joint_state[3])    # Applied effort\n\n        self.joint_state_pub.publish(msg)\n\n    def publish_imu_data(self):\n        """Publish IMU data from robot base"""\n        # Get robot base position and orientation\n        pos, orn = p.getBasePositionAndOrientation(self.robot_id)\n\n        # Get base velocity\n        lin_vel, ang_vel = p.getBaseVelocity(self.robot_id)\n\n        # Create IMU message\n        imu_msg = Imu()\n        imu_msg.header.stamp = self.get_clock().now().to_msg()\n        imu_msg.header.frame_id = "base_imu_link"\n\n        # Set orientation (from quaternion)\n        imu_msg.orientation.x = orn[0]\n        imu_msg.orientation.y = orn[1]\n        imu_msg.orientation.z = orn[2]\n        imu_msg.orientation.w = orn[3]\n\n        # Set angular velocity\n        imu_msg.angular_velocity.x = ang_vel[0]\n        imu_msg.angular_velocity.y = ang_vel[1]\n        imu_msg.angular_velocity.z = ang_vel[2]\n\n        # In simulation, linear acceleration can be approximated from velocity change\n        # This is a simplified approach - in real systems it would come from IMU\n        imu_msg.linear_acceleration.x = 0.0  # Would be from IMU in real robot\n        imu_msg.linear_acceleration.y = 0.0\n        imu_msg.linear_acceleration.z = -9.81  # Gravity\n\n        self.imu_pub.publish(imu_msg)\n\n    def apply_joint_commands(self, joint_commands):\n        """Apply commands to robot joints"""\n        for i, joint_idx in enumerate(self.joint_indices):\n            if i < len(joint_commands):\n                # Apply position control\n                p.setJointMotorControl2(\n                    bodyIndex=self.robot_id,\n                    jointIndex=joint_idx,\n                    controlMode=p.POSITION_CONTROL,\n                    targetPosition=joint_commands[i],\n                    force=100  # Max force/torque\n                )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    simulator = PhysicsBasedRobotSimulator()\n\n    try:\n        rclpy.spin(simulator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        p.disconnect(physicsClientId=simulator.physics_client)\n        simulator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"advanced-physics-configuration-with-custom-constraints",children:"Advanced Physics Configuration with Custom Constraints"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import pybullet as p\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass AdvancedPhysicsSimulator:\n    def __init__(self):\n        # Connect to physics engine\n        self.physics_client = p.connect(p.GUI)\n        p.setGravity(0, 0, -9.81)\n\n        # Enable real-time simulation\n        p.setRealTimeSimulation(0)  # We\'ll step manually\n\n        # Set physics parameters for accuracy\n        p.setPhysicsEngineParameter(\n            fixedTimeStep=1.0/240.0,  # 240 Hz physics update\n            numSolverIterations=10,   # More iterations for stability\n            solverResidualThreshold=1e-6,  # Tighter solver tolerance\n            collisionFilterMode=0,    # Enable collision filtering\n            enableConeFriction=1,     # Enable cone friction model\n            enableFileCaching=1,      # Cache collision shapes\n            deterministicOverlappingPairs=1,  # Deterministic collision handling\n            allowedCcdPenetration=0.0,  # No CCD penetration\n            numSoftBodyIterations=10,   # For soft body simulation\n            mpNumThreads=1,            # Single thread for reproducibility\n            sparseSdfVoxelSize=0.2     # Sparse SDF voxel size\n        )\n\n        self.objects = {}\n        self.constraints = []\n\n    def create_rigid_body(self, shape_type, dimensions, mass, position, orientation=[0, 0, 0, 1]):\n        """Create a rigid body with specified properties"""\n        # Create collision shape\n        if shape_type == "box":\n            col_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=dimensions)\n        elif shape_type == "sphere":\n            col_shape = p.createCollisionShape(p.GEOM_SPHERE, radius=dimensions[0])\n        elif shape_type == "cylinder":\n            col_shape = p.createCollisionShape(p.GEOM_CYLINDER, radius=dimensions[0], length=dimensions[1])\n        else:\n            raise ValueError(f"Unsupported shape type: {shape_type}")\n\n        # Create visual shape (optional)\n        vis_shape = p.createVisualShape(shape_type, halfExtents=dimensions if shape_type == "box" else None)\n\n        # Create multi-body\n        body_id = p.createMultiBody(\n            baseMass=mass,\n            baseCollisionShapeIndex=col_shape,\n            baseVisualShapeIndex=vis_shape,\n            basePosition=position,\n            baseOrientation=orientation\n        )\n\n        # Store body information\n        self.objects[body_id] = {\n            \'type\': shape_type,\n            \'dimensions\': dimensions,\n            \'mass\': mass,\n            \'position\': position,\n            \'orientation\': orientation\n        }\n\n        return body_id\n\n    def create_articulated_robot(self):\n        """Create a simple articulated robot with joints"""\n        # Create base link\n        base_id = self.create_rigid_body("box", [0.3, 0.3, 0.2], 10.0, [0, 0, 1])\n\n        # Create a simple arm link\n        arm_id = self.create_rigid_body("box", [0.1, 0.1, 0.5], 2.0, [0, 0, 0.5])\n\n        # Create revolute joint between base and arm\n        joint_id = p.createConstraint(\n            parentBodyUniqueId=base_id,\n            parentLinkIndex=-1,  # Base link\n            childBodyUniqueId=arm_id,\n            childLinkIndex=-1,   # Base link of child\n            jointType=p.JOINT_REVOLUTE,\n            jointAxis=[0, 0, 1],  # Z-axis rotation\n            parentFramePosition=[0, 0, 0.1],  # Position in parent frame\n            childFramePosition=[0, 0, -0.25]  # Position in child frame\n        )\n\n        # Configure joint limits\n        p.setJointMotorControl2(\n            bodyIndex=base_id,\n            jointIndex=joint_id,\n            controlMode=p.POSITION_CONTROL,\n            targetPosition=0,\n            force=100\n        )\n\n        # Store constraint information\n        self.constraints.append({\n            \'id\': joint_id,\n            \'parent\': base_id,\n            \'child\': arm_id,\n            \'type\': \'revolute\'\n        })\n\n        return base_id, arm_id\n\n    def set_joint_dynamics(self, body_id, joint_index, friction, damping, max_force):\n        """Configure joint dynamics parameters"""\n        p.changeDynamics(\n            body_id,\n            joint_index,\n            jointLowerLimit=-3.14,  # -\u03c0\n            jointUpperLimit=3.14,   # \u03c0\n            jointFrictionAnchorThreshold=0.01,\n            jointLimitForce=1000,\n            jointLimitDamping=0.1\n        )\n\n        # Set friction and damping\n        p.setJointMotorControl2(\n            bodyUniqueId=body_id,\n            jointIndex=joint_index,\n            controlMode=p.VELOCITY_CONTROL,\n            force=max_force,\n            positionGain=0.1,\n            velocityGain=0.1\n        )\n\n    def simulate_step(self, dt=1.0/240.0):\n        """Execute one simulation step"""\n        p.stepSimulation()\n\n    def get_body_state(self, body_id):\n        """Get position, orientation, velocity of a body"""\n        pos, orn = p.getBasePositionAndOrientation(body_id)\n        lin_vel, ang_vel = p.getBaseVelocity(body_id)\n\n        return {\n            \'position\': pos,\n            \'orientation\': orn,\n            \'linear_velocity\': lin_vel,\n            \'angular_velocity\': ang_vel\n        }\n\n    def apply_external_force(self, body_id, force, position, link_index=-1):\n        """Apply external force to a body"""\n        p.applyExternalForce(\n            objectUniqueId=body_id,\n            linkIndex=link_index,\n            forceObj=force,\n            posObj=position,\n            flags=p.WORLD_FRAME\n        )\n\n    def cleanup(self):\n        """Clean up physics simulation"""\n        p.disconnect(self.physics_client)\n\n# Example usage\ndef example_usage():\n    sim = AdvancedPhysicsSimulator()\n\n    # Create a robot\n    base_id, arm_id = sim.create_articulated_robot()\n\n    # Simulate for a few steps\n    for i in range(1000):\n        sim.simulate_step()\n\n        # Get robot state\n        state = sim.get_body_state(base_id)\n        print(f"Step {i}: Position = {state[\'position\']}")\n\n        if i % 100 == 0:\n            # Apply a small external force periodically\n            sim.apply_external_force(base_id, [10, 0, 0], [0, 0, 0])\n\n    sim.cleanup()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"physics-validation-and-comparison",children:"Physics Validation and Comparison"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import integrate\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\n\nclass PhysicsValidator(Node):\n    def __init__(self):\n        super().__init__('physics_validator')\n\n        # Subscribers for simulated and real robot data\n        self.sim_joint_sub = self.create_subscription(\n            JointState, '/sim/joint_states', self.sim_joint_callback, 10\n        )\n        self.real_joint_sub = self.create_subscription(\n            JointState, '/real/joint_states', self.real_joint_callback, 10\n        )\n\n        # Timer for validation\n        self.validation_timer = self.create_timer(1.0, self.validate_physics)\n\n        # Data storage for comparison\n        self.sim_data = {'timestamps': [], 'positions': [], 'velocities': []}\n        self.real_data = {'timestamps': [], 'positions': [], 'velocities': []}\n\n        # Physics model parameters (for validation)\n        self.robot_params = {\n            'mass': 10.0,\n            'length': 1.0,\n            'inertia': 0.5,\n            'gravity': 9.81,\n            'friction': 0.1\n        }\n\n        self.get_logger().info('Physics validator initialized')\n\n    def sim_joint_callback(self, msg):\n        \"\"\"Store simulated joint data\"\"\"\n        self.sim_data['timestamps'].append(self.get_clock().now().nanoseconds / 1e9)\n        self.sim_data['positions'].append(list(msg.position))\n        self.sim_data['velocities'].append(list(msg.velocity))\n\n    def real_joint_callback(self, msg):\n        \"\"\"Store real robot joint data\"\"\"\n        self.real_data['timestamps'].append(self.get_clock().now().nanoseconds / 1e9)\n        self.real_data['positions'].append(list(msg.position))\n        self.real_data['velocities'].append(list(msg.velocity))\n\n    def validate_physics(self):\n        \"\"\"Validate simulation against real robot physics\"\"\"\n        if len(self.sim_data['positions']) < 10 or len(self.real_data['positions']) < 10:\n            self.get_logger().info('Insufficient data for validation')\n            return\n\n        # Calculate validation metrics\n        pos_error = self.calculate_position_error()\n        vel_error = self.calculate_velocity_error()\n        dynamics_error = self.calculate_dynamics_error()\n\n        self.get_logger().info(f'Physics Validation Results:')\n        self.get_logger().info(f'  Position RMSE: {pos_error:.4f}')\n        self.get_logger().info(f'  Velocity RMSE: {vel_error:.4f}')\n        self.get_logger().info(f'  Dynamics Error: {dynamics_error:.4f}')\n\n        # Suggest physics parameter adjustments if errors are high\n        if pos_error > 0.1 or vel_error > 0.1:\n            self.suggest_parameter_adjustments()\n\n    def calculate_position_error(self):\n        \"\"\"Calculate RMSE of position tracking\"\"\"\n        if len(self.sim_data['positions']) != len(self.real_data['positions']):\n            # Interpolate to match lengths\n            min_len = min(len(self.sim_data['positions']), len(self.real_data['positions']))\n            sim_pos = np.array(self.sim_data['positions'][-min_len:])\n            real_pos = np.array(self.real_data['positions'][-min_len:])\n        else:\n            sim_pos = np.array(self.sim_data['positions'])\n            real_pos = np.array(self.real_data['positions'])\n\n        error = np.sqrt(np.mean((sim_pos - real_pos)**2))\n        return error\n\n    def calculate_velocity_error(self):\n        \"\"\"Calculate RMSE of velocity tracking\"\"\"\n        if len(self.sim_data['velocities']) != len(self.real_data['velocities']):\n            # Interpolate to match lengths\n            min_len = min(len(self.sim_data['velocities']), len(self.real_data['velocities']))\n            sim_vel = np.array(self.sim_data['velocities'][-min_len:])\n            real_vel = np.array(self.real_data['velocities'][-min_len:])\n        else:\n            sim_vel = np.array(self.sim_data['velocities'])\n            real_vel = np.array(self.real_data['velocities'])\n\n        error = np.sqrt(np.mean((sim_vel - real_vel)**2))\n        return error\n\n    def calculate_dynamics_error(self):\n        \"\"\"Calculate error in dynamics model\"\"\"\n        # This is a simplified dynamics validation\n        # In practice, you would compare simulated vs real acceleration\n        # or other dynamic properties\n\n        # Estimate acceleration from velocity data\n        if len(self.sim_data['velocities']) > 2 and len(self.real_data['velocities']) > 2:\n            sim_velocities = np.array(self.sim_data['velocities'][-10:])  # Last 10 samples\n            real_velocities = np.array(self.real_data['velocities'][-10:])\n\n            # Calculate approximate accelerations\n            dt = 0.1  # Assuming 10Hz data\n            sim_acc = np.diff(sim_velocities, axis=0) / dt\n            real_acc = np.diff(real_velocities, axis=0) / dt\n\n            # Calculate error in acceleration\n            acc_error = np.sqrt(np.mean((sim_acc - real_acc)**2))\n            return acc_error\n        else:\n            return float('inf')\n\n    def suggest_parameter_adjustments(self):\n        \"\"\"Suggest physics parameter adjustments based on validation\"\"\"\n        self.get_logger().info('Suggested physics parameter adjustments:')\n\n        # Analyze position error patterns\n        pos_error = self.calculate_position_error()\n        if pos_error > 0.1:\n            self.get_logger().info('  - Consider adjusting mass parameters')\n            self.get_logger().info('  - Check friction coefficients')\n            self.get_logger().info('  - Verify center of mass locations')\n\n        # Analyze velocity error patterns\n        vel_error = self.calculate_velocity_error()\n        if vel_error > 0.1:\n            self.get_logger().info('  - Consider adjusting damping parameters')\n            self.get_logger().info('  - Check joint friction values')\n            self.get_logger().info('  - Verify actuator dynamics')\n\n        # Analyze dynamics error\n        dyn_error = self.calculate_dynamics_error()\n        if dyn_error > 1.0:\n            self.get_logger().info('  - Consider adjusting inertia tensors')\n            self.get_logger().info('  - Check constraint parameters')\n            self.get_logger().info('  - Verify contact properties')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = PhysicsValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"practical-lab--simulation",children:"Practical Lab / Simulation"}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-1-physics-engine-setup-and-configuration",children:"Lab Exercise 1: Physics Engine Setup and Configuration"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Install and set up PyBullet physics engine:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pip install pybullet\n"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Create a basic physics simulation with a ground plane and simple objects"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Configure physics parameters for accuracy vs performance trade-offs"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Experiment with different time step sizes and solver iterations"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Observe the effect on simulation stability and accuracy"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-2-rigid-body-dynamics",children:"Lab Exercise 2: Rigid Body Dynamics"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create rigid bodies with different shapes (box, sphere, cylinder)"}),"\n",(0,t.jsx)(e.li,{children:"Configure mass, inertia, and friction properties"}),"\n",(0,t.jsx)(e.li,{children:"Apply forces and torques to observe dynamic responses"}),"\n",(0,t.jsx)(e.li,{children:"Implement collision detection between objects"}),"\n",(0,t.jsx)(e.li,{children:"Analyze the conservation of momentum and energy in the system"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-3-articulated-robot-simulation",children:"Lab Exercise 3: Articulated Robot Simulation"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a simple multi-link robot using constraints/joints"}),"\n",(0,t.jsx)(e.li,{children:"Implement different joint types (revolute, prismatic, fixed)"}),"\n",(0,t.jsx)(e.li,{children:"Configure joint limits and dynamics properties"}),"\n",(0,t.jsx)(e.li,{children:"Apply control inputs and observe robot motion"}),"\n",(0,t.jsx)(e.li,{children:"Validate that the robot behaves according to physical laws"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-4-contact-mechanics-and-friction",children:"Lab Exercise 4: Contact Mechanics and Friction"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Set up scenarios with different contact materials"}),"\n",(0,t.jsx)(e.li,{children:"Configure friction coefficients and observe sliding vs rolling behavior"}),"\n",(0,t.jsx)(e.li,{children:"Implement contact force analysis"}),"\n",(0,t.jsx)(e.li,{children:"Study the effect of friction on robot locomotion"}),"\n",(0,t.jsx)(e.li,{children:"Compare different friction models (Coulomb, Stribeck, etc.)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-5-physics-validation",children:"Lab Exercise 5: Physics Validation"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a simple physical system with known analytical solution"}),"\n",(0,t.jsx)(e.li,{children:"Simulate the system in your physics engine"}),"\n",(0,t.jsx)(e.li,{children:"Compare simulation results with analytical solution"}),"\n",(0,t.jsx)(e.li,{children:"Identify sources of numerical error and discretization effects"}),"\n",(0,t.jsx)(e.li,{children:"Tune physics parameters to minimize errors"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"lab-exercise-6-performance-optimization",children:"Lab Exercise 6: Performance Optimization"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Measure simulation performance with different configurations"}),"\n",(0,t.jsx)(e.li,{children:"Analyze the trade-off between accuracy and speed"}),"\n",(0,t.jsx)(e.li,{children:"Implement performance optimizations (caching, simplification)"}),"\n",(0,t.jsx)(e.li,{children:"Test optimization effectiveness with complex scenes"}),"\n",(0,t.jsx)(e.li,{children:"Document performance vs. accuracy characteristics"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"real-world-mapping",children:"Real-World Mapping"}),"\n",(0,t.jsx)(e.h3,{id:"industrial-applications",children:"Industrial Applications"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manufacturing"}),": Physics simulation for robot path planning and collision avoidance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Logistics"}),": Warehouse robot simulation with accurate dynamics for safety validation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Automotive"}),": Physics-based simulation for autonomous vehicle development"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"research-applications",children:"Research Applications"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Humanoid Robotics"}),": Balance control development using physics-accurate simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manipulation Research"}),": Grasping and manipulation skill development"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Locomotion Studies"}),": Walking and running gait optimization"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"key-success-factors",children:"Key Success Factors"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model Accuracy"}),": Proper representation of robot dynamics and environmental physics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Computational Efficiency"}),": Balance between accuracy and real-time performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Validation"}),": Systematic comparison between simulation and reality"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability"}),": Numerical stability of physics integration algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Scalability"}),": Ability to handle complex multi-body systems"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Chapter 4 has covered the fundamentals of physics-based simulation for Physical AI and humanoid robotics. We've explored physics engine architecture, rigid body dynamics, articulated systems, and contact mechanics. The examples demonstrated practical implementations of physics simulation with PyBullet, advanced configuration techniques, and validation methods. The hands-on lab exercises provide experience with physics engine setup, rigid body dynamics, articulated robot simulation, and performance optimization. This foundation is essential for creating accurate, stable, and efficient physics simulations that enable humanoid robots to learn and operate effectively in the physical world."})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var s=i(6540);const t={},o=s.createContext(t);function a(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);