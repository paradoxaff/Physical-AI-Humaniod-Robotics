"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[842],{6121:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"modules/module-03-isaac/isaac-sim","title":"Chapter 1 - Isaac Sim","description":"Learning Objectives","source":"@site/docs/modules/module-03-isaac/isaac-sim.mdx","sourceDirName":"modules/module-03-isaac","slug":"/modules/module-03-isaac/isaac-sim","permalink":"/docs/modules/module-03-isaac/isaac-sim","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/modules/module-03-isaac/isaac-sim.mdx","tags":[],"version":"current","frontMatter":{"title":"Chapter 1 - Isaac Sim","sidebar_label":"Isaac Sim"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS","permalink":"/docs/modules/module-03-isaac/isaac-ros"},"next":{"title":"Overview","permalink":"/docs/modules/module-04-vla-capstone/"}}');var a=i(4848),r=i(8453);const o={title:"Chapter 1 - Isaac Sim",sidebar_label:"Isaac Sim"},t="Chapter 1: Isaac Sim",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Physical AI Concept",id:"physical-ai-concept",level:2},{value:"System Architecture",id:"system-architecture",level:2},{value:"Isaac Sim Architecture",id:"isaac-sim-architecture",level:3},{value:"Isaac Sim Sensor Pipeline",id:"isaac-sim-sensor-pipeline",level:3},{value:"Tools &amp; Software",id:"tools--software",level:2},{value:"Code / Configuration Examples",id:"code--configuration-examples",level:2},{value:"Isaac Sim Robot Configuration (USD Format)",id:"isaac-sim-robot-configuration-usd-format",level:3},{value:"Isaac Sim Python Configuration",id:"isaac-sim-python-configuration",level:3},{value:"Isaac Sim ROS Bridge Configuration",id:"isaac-sim-ros-bridge-configuration",level:3},{value:"Practical Lab / Simulation",id:"practical-lab--simulation",level:2},{value:"Lab Exercise 1: Isaac Sim Installation and Setup",id:"lab-exercise-1-isaac-sim-installation-and-setup",level:3},{value:"Lab Exercise 2: Robot Model Import",id:"lab-exercise-2-robot-model-import",level:3},{value:"Lab Exercise 3: Sensor Configuration",id:"lab-exercise-3-sensor-configuration",level:3},{value:"Lab Exercise 4: Environment Design",id:"lab-exercise-4-environment-design",level:3},{value:"Lab Exercise 5: ROS Integration",id:"lab-exercise-5-ros-integration",level:3},{value:"Lab Exercise 6: AI Training Environment",id:"lab-exercise-6-ai-training-environment",level:3},{value:"Real-World Mapping",id:"real-world-mapping",level:2},{value:"Industrial Applications",id:"industrial-applications",level:3},{value:"Research Applications",id:"research-applications",level:3},{value:"Key Success Factors",id:"key-success-factors",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-1-isaac-sim",children:"Chapter 1: Isaac Sim"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Install and configure NVIDIA Isaac Sim for robotics simulation"}),"\n",(0,a.jsx)(e.li,{children:"Create and configure virtual robots with realistic sensors and actuators"}),"\n",(0,a.jsx)(e.li,{children:"Design complex environments for robot training and testing"}),"\n",(0,a.jsx)(e.li,{children:"Implement photorealistic rendering for computer vision training"}),"\n",(0,a.jsx)(e.li,{children:"Integrate Isaac Sim with ROS 2 for seamless simulation-to-reality workflows"}),"\n",(0,a.jsx)(e.li,{children:"Utilize domain randomization techniques for robust AI model training"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"physical-ai-concept",children:"Physical AI Concept"}),"\n",(0,a.jsx)(e.p,{children:"Isaac Sim represents NVIDIA's advanced simulation platform specifically designed for Physical AI and robotics development. It combines high-fidelity physics simulation with photorealistic rendering, enabling the creation of virtual environments that closely match real-world conditions. For Physical AI systems, Isaac Sim serves as a crucial bridge between pure digital AI and physical reality, allowing robots to learn complex behaviors in safe, controlled, and cost-effective virtual environments before deployment to real hardware."}),"\n",(0,a.jsx)(e.p,{children:"Isaac Sim's role in Physical AI includes:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Photorealistic Training"}),": High-quality rendering for training computer vision systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Physics Accuracy"}),": Realistic physics simulation for testing robot dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Simulation"}),": Accurate modeling of cameras, LIDAR, IMU, and other sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Domain Randomization"}),": Techniques to improve Sim2Real transfer"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scalable Training"}),": Cloud deployment for large-scale AI training"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-architecture",children:"Isaac Sim Architecture"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Isaac Sim Architecture:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Omniverse Platform                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   USD Format    \u2502  \u2502   Physics       \u2502  \u2502   Rendering     \u2502    \u2502\n\u2502  \u2502   (Universal    \u2502  \u2502   Engine        \u2502  \u2502   Engine        \u2502    \u2502\n\u2502  \u2502   Scene         \u2502  \u2502  \u2022 PhysX       \u2502  \u2502  \u2022 RTX Ray      \u2502    \u2502\n\u2502  \u2502   Description)  \u2502  \u2502  \u2022 Collision   \u2502  \u2502    Tracing      \u2502    \u2502\n\u2502  \u2502  \u2022 Extensible  \u2502  \u2502  \u2022 Dynamics    \u2502  \u2502  \u2022 Global       \u2502    \u2502\n\u2502  \u2502  \u2022 Collaborative\u2502  \u2502  \u2022 Constraints \u2502  \u2502    Illumination \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502              \u2502                    \u2502                    \u2502           \u2502\n\u2502              \u25bc                    \u25bc                    \u25bc           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              Isaac Sim Core                                   \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502  \u2502\n\u2502  \u2502  \u2502  Robotics   \u2502  \u2502  Sensor     \u2502  \u2502  AI Training \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  Extensions \u2502  \u2502  Simulation \u2502  \u2502  Integration \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 URDF     \u2502  \u2502  \u2022 Camera   \u2502  \u2502  \u2022 Synthetic \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502    Import   \u2502  \u2502  \u2022 LIDAR    \u2502  \u2502    Data Gen \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 ROS      \u2502  \u2502  \u2022 IMU      \u2502  \u2502  \u2022 Domain   \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502    Bridge   \u2502  \u2502  \u2022 Force    \u2502  \u2502    Randomization\u2502      \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2022 GPS      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                     \u2502                            \u2502\n\u2502                                     \u25bc                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              ROS 2 Integration                              \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502  \u2502\n\u2502  \u2502  \u2502  Isaac ROS  \u2502  \u2502  Message    \u2502  \u2502  Control     \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  Bridge     \u2502  \u2502  Translation\u2502  \u2502  Interface   \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Topics   \u2502  \u2502  \u2022 Standard \u2502  \u2502  \u2022 Joint     \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Services \u2502  \u2502  Messages   \u2502  \u2502  Control    \u2502        \u2502  \u2502\n\u2502  \u2502  \u2502  \u2022 Actions  \u2502  \u2502  \u2022 Types    \u2502  \u2502  \u2022 Trajectory\u2502        \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-sensor-pipeline",children:"Isaac Sim Sensor Pipeline"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Sensor Simulation Pipeline:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Physics      \u2502\u2500\u2500\u2500\u25b6\u2502  Rendering      \u2502\u2500\u2500\u2500\u25b6\u2502  Post-         \u2502\n\u2502   Simulation   \u2502    \u2502  Engine         \u2502    \u2502  Processing    \u2502\n\u2502  \u2022 Dynamics    \u2502    \u2502  \u2022 RTX          \u2502    \u2502  \u2022 Noise       \u2502\n\u2502  \u2022 Collisions  \u2502    \u2502  \u2022 Lighting     \u2502    \u2502  \u2022 Distortion  \u2502\n\u2502  \u2022 Contacts    \u2502    \u2502  \u2022 Materials    \u2502    \u2502  \u2022 Calibration \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502  \u2022 Shadows     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502  \u2022 Reflections  \u2502              \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u25bc\n                                    \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  ROS 2 Output   \u2502\n                                             \u2502  \u2022 Standard     \u2502\n                                             \u2502    Message      \u2502\n                                             \u2502    Types        \u2502\n                                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(e.h2,{id:"tools--software",children:"Tools & Software"}),"\n",(0,a.jsx)(e.p,{children:"This chapter uses:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"NVIDIA Isaac Sim"})," - Core simulation environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Omniverse"})," - Underlying platform for Isaac Sim"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"USD (Universal Scene Description)"})," - Format for 3D scenes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"PhysX"})," - NVIDIA's physics engine"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"RTX Ray Tracing"})," - For photorealistic rendering"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ROS 2 Humble Hawksbill"})," - Integration with robotics framework"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Isaac ROS Bridge"})," - For ROS 2 communication"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Isaac Sim Extensions"})," - Additional functionality packages"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"code--configuration-examples",children:"Code / Configuration Examples"}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-robot-configuration-usd-format",children:"Isaac Sim Robot Configuration (USD Format)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-usd",children:'# Robot configuration in USD format\n# File: /path/to/robot.usd\n\n#-------------------\n# Robot Definition\n#-------------------\ndef Xform "Robot"\n{\n    # Robot properties\n    uniform string physics:articulationRoot = "/Robot"\n    double3 xformOp:translate = (0, 0, 0.5)\n    double4 xformOp:orient = (0, 0, 0, 1)\n    double xformOp:scale = 1\n\n    # Base link\n    def Xform "Base"\n    {\n        def PhysicsRigidBodyAPI "Base"\n        {\n            bool physics:kinematicEnabled = False\n            double physics:mass = 10.0\n            double3 physics:centerOfMass = (0, 0, 0)\n        }\n\n        def Mesh "BaseMesh"\n        {\n            int[] faceVertexCounts = [4, 4, 4, 4, 4, 4]\n            int[] faceVertexIndices = [0, 1, 2, 3, 4, 5, 6, 7, 0, 3, 7, 4, 1, 5, 6, 2, 0, 4, 5, 1, 2, 6, 7, 3]\n            float3[] points = [(-0.15, -0.15, -0.25), (0.15, -0.15, -0.25), (0.15, 0.15, -0.25), (-0.15, 0.15, -0.25), (-0.15, -0.15, 0.25), (0.15, -0.15, 0.25), (0.15, 0.15, 0.25), (-0.15, 0.15, 0.25)]\n            float2[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1)]\n            normal3f[] normals = [(0, 0, -1), (0, 0, 1), (0, -1, 0), (0, 1, 0), (-1, 0, 0), (1, 0, 0)]\n        }\n\n        def PhysicsShapeAPI "BaseCollision"\n        {\n            double3 extent = (0.15, 0.15, 0.25)\n        }\n    }\n\n    # Head link\n    def Xform "Head"\n    {\n        double3 xformOp:translate = (0, 0, 0.3)\n        add xformOp:reparent:rel = [</Robot/Base>]\n\n        def PhysicsRigidBodyAPI "Head"\n        {\n            bool physics:kinematicEnabled = False\n            double physics:mass = 2.0\n        }\n\n        def Sphere "HeadMesh"\n        {\n            float radius = 0.1\n        }\n\n        def PhysicsShapeAPI "HeadCollision"\n        {\n            double3 extent = (0.1, 0.1, 0.1)\n        }\n    }\n\n    # Camera sensor\n    def Camera "Camera"\n    {\n        double3 xformOp:translate = (0.15, 0, 0.1)\n        add xformOp:reparent:rel = [</Robot/Base>]\n\n        # Camera properties\n        float focalLength = 24.0\n        float horizontalAperture = 36.0\n        float verticalAperture = 24.0\n        float focusDistance = 10.0\n        float fStop = 1.4\n    }\n\n    # IMU sensor\n    def Xform "Imu"\n    {\n        double3 xformOp:translate = (0, 0, 0.1)\n        add xformOp:reparent:rel = [</Robot/Base>]\n    }\n\n    # Joint between base and head\n    def PhysicsJoint "HeadJoint"\n    {\n        add xformOp:reparent:rel = [</Robot>]\n        rel physics:body0 = </Robot/Base>\n        rel physics:body1 = </Robot/Head>\n        PhysicsRevoluteJointAPI {\n            float3 physics:axis = (0, 0, 1)\n            float physics:lowerLimit = -1.57\n            float physics:upperLimit = 1.57\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-python-configuration",children:"Isaac Sim Python Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import omni\nfrom pxr import Usd, UsdGeom, Gf, Sdf, UsdPhysics, PhysxSchema\nimport carb\nimport omni.usd\nimport omni.kit.commands\nimport numpy as np\n\nclass IsaacSimRobotCreator:\n    def __init__(self):\n        self.stage = None\n        self.robot_path = None\n\n    def create_stage(self, stage_path="/Isaac/Robots/MyRobot"):\n        """Create a new USD stage for the robot"""\n        self.stage = omni.usd.get_context().get_stage()\n\n        # Create robot prim\n        self.robot_path = Sdf.Path(stage_path)\n        robot_prim = UsdGeom.Xform.Define(self.stage, self.robot_path)\n\n        return robot_prim\n\n    def add_rigid_body(self, parent_path, name, mass, position, size=(0.3, 0.3, 0.5)):\n        """Add a rigid body to the stage"""\n        body_path = parent_path.AppendChild(name)\n        body_xform = UsdGeom.Xform.Define(self.stage, body_path)\n\n        # Set transform\n        body_xform.AddTranslateOp().Set(Gf.Vec3d(position[0], position[1], position[2]))\n\n        # Create mesh\n        mesh = UsdGeom.Cube.Define(self.stage, body_path.AppendChild("mesh"))\n        mesh.GetSizeAttr().Set(max(size))\n\n        # Add physics properties\n        UsdPhysics.RigidBodyAPI.Apply(body_xform.GetPrim())\n        phys_body = PhysxSchema.PhysxRigidBodyAPI.Apply(body_xform.GetPrim())\n        phys_body.GetMassAttr().Set(mass)\n\n        # Add collision\n        collision_api = UsdPhysics.CollisionAPI.Apply(mesh.GetPrim())\n\n        return body_xform\n\n    def add_joint(self, parent_body_path, child_body_path, joint_type="revolute"):\n        """Add a joint between two bodies"""\n        joint_path = Sdf.Path(f"{parent_body_path.pathString}/joint_{joint_type}")\n\n        if joint_type == "revolute":\n            joint = UsdPhysics.RevoluteJoint.Define(self.stage, joint_path)\n        else:\n            joint = UsdPhysics.FixedJoint.Define(self.stage, joint_path)\n\n        joint.GetBody0Rel().SetTargets([parent_body_path])\n        joint.GetBody1Rel().SetTargets([child_body_path])\n\n        return joint\n\n    def add_sensor(self, parent_path, sensor_type, position, name):\n        """Add a sensor to the robot"""\n        sensor_path = parent_path.AppendChild(name)\n\n        if sensor_type == "camera":\n            camera = UsdGeom.Camera.Define(self.stage, sensor_path)\n            camera_xform = UsdGeom.Xformable(camera)\n            camera_xform.AddTranslateOp().Set(Gf.Vec3d(position[0], position[1], position[2]))\n\n            # Set camera properties\n            camera.GetFocalLengthAttr().Set(24.0)\n            camera.GetHorizontalApertureAttr().Set(36.0)\n            camera.GetVerticalApertureAttr().Set(24.0)\n\n            return camera\n        elif sensor_type == "lidar":\n            # For LiDAR, we\'d typically use Isaac Sim\'s LiDAR extension\n            # This is a placeholder for the actual implementation\n            lidar_xform = UsdGeom.Xform.Define(self.stage, sensor_path)\n            lidar_xform.AddTranslateOp().Set(Gf.Vec3d(position[0], position[1], position[2]))\n            return lidar_xform\n\n    def create_simple_robot(self):\n        """Create a simple robot with base, head, and sensors"""\n        # Create the stage\n        robot_prim = self.create_stage()\n\n        # Add base link\n        base = self.add_rigid_body(\n            self.robot_path,\n            "base",\n            mass=10.0,\n            position=(0, 0, 0.5),\n            size=(0.3, 0.3, 0.5)\n        )\n\n        # Add head link\n        head = self.add_rigid_body(\n            self.robot_path,\n            "head",\n            mass=2.0,\n            position=(0, 0, 0.8),\n            size=(0.2, 0.2, 0.2)\n        )\n\n        # Add joint between base and head\n        neck_joint = self.add_joint(\n            base.GetPath(),\n            head.GetPath(),\n            "revolute"\n        )\n\n        # Add camera sensor\n        camera = self.add_sensor(\n            base.GetPath(),\n            "camera",\n            position=(0.15, 0, 0.1),\n            name="camera_front"\n        )\n\n        # Add IMU sensor\n        imu = self.add_sensor(\n            base.GetPath(),\n            "imu",\n            position=(0, 0, 0.1),\n            name="imu_sensor"\n        )\n\n        carb.log_info("Simple robot created successfully")\n\n# Example usage within Isaac Sim extension\ndef example_usage():\n    creator = IsaacSimRobotCreator()\n    creator.create_simple_robot()\n'})}),"\n",(0,a.jsx)(e.h3,{id:"isaac-sim-ros-bridge-configuration",children:"Isaac Sim ROS Bridge Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, Imu, LaserScan\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\nimport cv2\nfrom cv_bridge import CvBridge\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.synthetic_utils import SyntheticDataHelper\nimport carb\n\nclass IsaacSimRosBridge(Node):\n    def __init__(self):\n        super().__init__(\'isaac_sim_ros_bridge\')\n\n        # Initialize CV bridge\n        self.bridge = CvBridge()\n\n        # Publishers for sensor data\n        self.image_pub = self.create_publisher(Image, \'/camera/rgb/image_raw\', 10)\n        self.imu_pub = self.create_publisher(Imu, \'/imu/data\', 10)\n        self.scan_pub = self.create_publisher(LaserScan, \'/scan\', 10)\n\n        # Subscriber for robot commands\n        self.cmd_vel_sub = self.create_subscription(\n            Twist, \'/cmd_vel\', self.cmd_vel_callback, 10\n        )\n\n        # Initialize Isaac Sim world\n        self.world = World(stage_units_in_meters=1.0)\n\n        # Robot properties\n        self.robot = None\n        self.camera = None\n        self.imu = None\n        self.lidar = None\n\n        # Simulation parameters\n        self.simulation_frequency = 60.0  # Hz\n        self.publish_frequency = 30.0     # Hz\n\n        # Timer for simulation steps\n        self.sim_timer = self.create_timer(\n            1.0/self.simulation_frequency,\n            self.simulation_step\n        )\n\n        # Timer for sensor publishing\n        self.publish_timer = self.create_timer(\n            1.0/self.publish_frequency,\n            self.publish_sensors\n        )\n\n        self.get_logger().info(\'Isaac Sim ROS bridge initialized\')\n\n    def setup_simulation(self):\n        """Set up the Isaac Sim environment"""\n        try:\n            # Add ground plane\n            self.world.scene.add_default_ground_plane()\n\n            # Add a simple robot (using a pre-built asset or creating one)\n            # For this example, we\'ll use a simple rigid body\n            from omni.isaac.core.objects import DynamicCuboid\n\n            # Create a simple robot-like object\n            self.robot = self.world.scene.add(\n                DynamicCuboid(\n                    prim_path="/World/Robot",\n                    name="robot",\n                    position=np.array([0, 0, 1.0]),\n                    size=np.array([0.3, 0.3, 0.3]),\n                    mass=10.0\n                )\n            )\n\n            # Add sensors to the robot\n            self.setup_sensors()\n\n            # Reset the world\n            self.world.reset()\n\n            self.get_logger().info(\'Simulation environment set up successfully\')\n\n        except Exception as e:\n            self.get_logger().error(f\'Error setting up simulation: {e}\')\n\n    def setup_sensors(self):\n        """Set up sensors on the robot"""\n        try:\n            # For this example, we\'ll use Isaac Sim\'s built-in sensor support\n            # In practice, you\'d add specific sensor assets\n\n            # Add camera (this would be done through USD or Isaac Sim API)\n            # The camera would be attached to the robot\n\n            # Add IMU and other sensors\n            self.get_logger().info(\'Sensors set up successfully\')\n\n        except Exception as e:\n            self.get_logger().error(f\'Error setting up sensors: {e}\')\n\n    def cmd_vel_callback(self, msg):\n        """Process velocity commands from ROS"""\n        try:\n            # Apply forces or torques to the robot based on velocity command\n            # This is a simplified example - in practice, you\'d implement\n            # proper robot kinematics and dynamics\n\n            # Get current robot state\n            current_position, current_orientation = self.robot.get_world_pose()\n            current_linear_vel, current_angular_vel = self.robot.get_linear_velocity(), self.robot.get_angular_velocity()\n\n            # Calculate forces to achieve desired velocity\n            # (This is a simplified approach)\n            linear_force = np.array([msg.linear.x * 10.0, msg.linear.y * 10.0, 0.0])  # Apply force in X and Y\n            angular_torque = np.array([0.0, 0.0, msg.angular.z * 5.0])  # Apply torque around Z axis\n\n            # Apply forces to robot\n            self.robot.apply_forces_at_pos(forces=linear_force, positions=[current_position], is_global_forces=True)\n            self.robot.apply_torque(torque=angular_torque, is_global_torque=True)\n\n        except Exception as e:\n            self.get_logger().error(f\'Error processing cmd_vel: {e}\')\n\n    def simulation_step(self):\n        """Execute one step of Isaac Sim simulation"""\n        try:\n            # Step the physics simulation\n            self.world.step(render=True)\n\n        except Exception as e:\n            self.get_logger().error(f\'Error in simulation step: {e}\')\n\n    def publish_sensors(self):\n        """Publish sensor data to ROS topics"""\n        try:\n            # This is a simplified example\n            # In practice, you\'d get sensor data from Isaac Sim\n\n            # Publish dummy image data\n            self.publish_dummy_image()\n\n            # Publish dummy IMU data\n            self.publish_dummy_imu()\n\n            # Publish dummy laser scan data\n            self.publish_dummy_scan()\n\n        except Exception as e:\n            self.get_logger().error(f\'Error publishing sensors: {e}\')\n\n    def publish_dummy_image(self):\n        """Publish dummy camera image"""\n        # Create a dummy image for demonstration\n        img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)\n        ros_img = self.bridge.cv2_to_imgmsg(img, encoding="bgr8")\n        ros_img.header.stamp = self.get_clock().now().to_msg()\n        ros_img.header.frame_id = "camera_rgb_optical_frame"\n        self.image_pub.publish(ros_img)\n\n    def publish_dummy_imu(self):\n        """Publish dummy IMU data"""\n        from geometry_msgs.msg import Vector3\n        from std_msgs.msg import Header\n\n        imu_msg = Imu()\n        imu_msg.header.stamp = self.get_clock().now().to_msg()\n        imu_msg.header.frame_id = "imu_link"\n\n        # Set dummy values\n        imu_msg.orientation.x = 0.0\n        imu_msg.orientation.y = 0.0\n        imu_msg.orientation.z = 0.0\n        imu_msg.orientation.w = 1.0\n\n        imu_msg.angular_velocity.x = 0.0\n        imu_msg.angular_velocity.y = 0.0\n        imu_msg.angular_velocity.z = 0.0\n\n        imu_msg.linear_acceleration.x = 0.0\n        imu_msg.linear_acceleration.y = 0.0\n        imu_msg.linear_acceleration.z = 9.81  # Gravity\n\n        self.imu_pub.publish(imu_msg)\n\n    def publish_dummy_scan(self):\n        """Publish dummy laser scan data"""\n        scan_msg = LaserScan()\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\n        scan_msg.header.frame_id = "laser_frame"\n\n        # Set scan parameters\n        scan_msg.angle_min = -np.pi / 2\n        scan_msg.angle_max = np.pi / 2\n        scan_msg.angle_increment = np.pi / 180  # 1 degree\n        scan_msg.time_increment = 0.0\n        scan_msg.scan_time = 1.0 / 10.0  # 10 Hz\n        scan_msg.range_min = 0.1\n        scan_msg.range_max = 10.0\n\n        # Generate dummy ranges (180 points)\n        num_ranges = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment) + 1\n        scan_msg.ranges = [5.0 + np.random.uniform(-0.5, 0.5) for _ in range(num_ranges)]\n\n        self.scan_pub.publish(scan_msg)\n\ndef main(args=None):\n    # Note: This example shows the ROS bridge concept\n    # Actual Isaac Sim integration requires running within the Isaac Sim environment\n\n    rclpy.init(args=args)\n\n    # In a real implementation, this node would be run within Isaac Sim\n    # which has special requirements for the execution environment\n    node = IsaacSimRosBridge()\n\n    try:\n        # Set up the simulation\n        node.setup_simulation()\n\n        # Run the node\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-lab--simulation",children:"Practical Lab / Simulation"}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-1-isaac-sim-installation-and-setup",children:"Lab Exercise 1: Isaac Sim Installation and Setup"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Install NVIDIA Isaac Sim following the official documentation"}),"\n",(0,a.jsx)(e.li,{children:"Verify system requirements (RTX GPU, Omniverse access)"}),"\n",(0,a.jsx)(e.li,{children:"Launch Isaac Sim and familiarize yourself with the interface"}),"\n",(0,a.jsx)(e.li,{children:"Load a sample scene to verify functionality"}),"\n",(0,a.jsx)(e.li,{children:"Explore the different panels and tools available"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-2-robot-model-import",children:"Lab Exercise 2: Robot Model Import"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Create or obtain a URDF robot model"}),"\n",(0,a.jsx)(e.li,{children:"Import the robot into Isaac Sim using the URDF importer"}),"\n",(0,a.jsx)(e.li,{children:"Verify that all joints and links are correctly imported"}),"\n",(0,a.jsx)(e.li,{children:"Test basic joint movement and kinematics"}),"\n",(0,a.jsx)(e.li,{children:"Configure physical properties (mass, friction, etc.)"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-3-sensor-configuration",children:"Lab Exercise 3: Sensor Configuration"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["Add different sensor types to your robot:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"RGB camera with configurable parameters"}),"\n",(0,a.jsx)(e.li,{children:"Depth camera for 3D perception"}),"\n",(0,a.jsx)(e.li,{children:"IMU for orientation and acceleration"}),"\n",(0,a.jsx)(e.li,{children:"LIDAR for 2D/3D mapping"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.li,{children:"Configure sensor parameters to match real hardware"}),"\n",(0,a.jsx)(e.li,{children:"Verify sensor data publishing in Isaac Sim"}),"\n",(0,a.jsx)(e.li,{children:"Export sensor configuration for ROS integration"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-4-environment-design",children:"Lab Exercise 4: Environment Design"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["Create a complex environment for robot testing:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Add obstacles and navigation challenges"}),"\n",(0,a.jsx)(e.li,{children:"Configure lighting conditions"}),"\n",(0,a.jsx)(e.li,{children:"Add textured surfaces for visual perception"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.li,{children:"Test robot navigation in the environment"}),"\n",(0,a.jsx)(e.li,{children:"Adjust environment parameters for different scenarios"}),"\n",(0,a.jsx)(e.li,{children:"Implement domain randomization techniques"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-5-ros-integration",children:"Lab Exercise 5: ROS Integration"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Set up the Isaac Sim ROS bridge"}),"\n",(0,a.jsx)(e.li,{children:"Configure ROS topics for sensor data and control commands"}),"\n",(0,a.jsx)(e.li,{children:"Test communication between Isaac Sim and ROS nodes"}),"\n",(0,a.jsx)(e.li,{children:"Implement a simple control node that drives the robot"}),"\n",(0,a.jsx)(e.li,{children:"Verify sensor data publishing to ROS topics"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lab-exercise-6-ai-training-environment",children:"Lab Exercise 6: AI Training Environment"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Design an environment specifically for AI training"}),"\n",(0,a.jsx)(e.li,{children:"Implement domain randomization for robust model training"}),"\n",(0,a.jsx)(e.li,{children:"Generate synthetic training data using Isaac Sim"}),"\n",(0,a.jsx)(e.li,{children:"Train a simple perception model using synthetic data"}),"\n",(0,a.jsx)(e.li,{children:"Evaluate model performance on real-world data"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"real-world-mapping",children:"Real-World Mapping"}),"\n",(0,a.jsx)(e.h3,{id:"industrial-applications",children:"Industrial Applications"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Manufacturing"}),": Isaac Sim for training robots in factory environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Logistics"}),": Warehouse robot simulation with realistic environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Agriculture"}),": Autonomous vehicle training in diverse terrain conditions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"research-applications",children:"Research Applications"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Humanoid Robotics"}),": Balance and locomotion training in Isaac Sim"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Computer Vision"}),": Synthetic data generation for perception systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Autonomous Systems"}),": Complex scenario training for safety validation"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"key-success-factors",children:"Key Success Factors"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fidelity"}),": Ensuring simulation accurately represents real-world physics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Efficiency"}),": Optimizing simulation performance for large-scale training"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Integration"}),": Seamless connection between simulation and real systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scalability"}),": Supporting cloud deployment for massive training runs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validation"}),": Systematic comparison between simulation and reality"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Chapter 1 has introduced NVIDIA Isaac Sim as a powerful platform for robotics simulation and AI training. We've explored Isaac Sim's architecture, which combines high-fidelity physics simulation with photorealistic rendering to create virtual environments that closely match real-world conditions. The examples demonstrated how to configure robots with realistic sensors and actuators, set up the ROS bridge for integration, and implement domain randomization techniques. The hands-on lab exercises provide practical experience with Isaac Sim installation, robot model import, sensor configuration, and AI training environment setup. This foundation enables the development of sophisticated simulation environments for training Physical AI systems that can effectively transfer to real-world applications."})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);